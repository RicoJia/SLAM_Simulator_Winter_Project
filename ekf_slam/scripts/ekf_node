#!/usr/bin/python
"""
This is the ekf node that filters the pose and the landmark locations, based on the control signal and the map.
How it works:
    a. Subscribe to /odom -> /baselink from odometer, gets the car's pose from odometry, then broadcast TF
    b. Subscribe to /landmarks to get landmark observations, then use EKF to estimate the robot and landmark pose
"""

import rospy
import numpy as np
import tf
from real_world.msg import LandmarkList
from sensor_msgs.msg import JointState
from nav_msgs.msg import Odometry
from ekf import ekf_object

#-------------------------------------------------------helper functions
# convert radians into [-pi, pi]
def normalize_angle(rad):
    _rad = rad - int((rad)/(2.0 * np.pi)) * (2.0*np.pi)
    if abs(_rad) > np.pi:
        _rad = -1.0*(2.0*np.pi-_rad) if _rad> 0 else 2.0*np.pi+_rad
    if _rad == -1*np.pi:
        _rad = np.pi
    return _rad

def SE2_inv(T):
    """Inverts a homogeneous transformation matrix

    :param T: A homogeneous transformation matrix
    :return: The inverse of T
    Uses the structure of transformation matrices to avoid taking a matrix
    inverse, for efficiency.

    Example input:
        T = np.array([[1, 0,  1],
                      [0, 1, 0],
                      [0, 0, 1] ])

    Output:
        T = np.array([[1, 0,  -1],
                      [0, 1, 0],
                      [0, 0, 1] ])
    """
    p = T[:2,2]
    R = T[:2, :2]
    Rt = np.array(R).T
    print ("R: ", R)
    print("T: ", T)
    return np.r_[np.c_[Rt, -np.dot(Rt, p)], [[0, 0, 1]]]
    
def theta_2_SO2(theta):
    """
    Input theta is a scalar vector
    Output: SO2 Rotation matrix
    """
    c = np.cos(theta)
    s = np.sin(theta)
    R = np.array([[c, -s],
                  [s, c]])
    return R

def pose_twist_to_SE2(pose_twist):
    '''
    In this program, we represent a robot's pose in a twist-like way: [theta,x,y]. However, this
    is NOT an actual twist, and the corresponding SE2 does not follow the standard "twist way". 
    Args:
        pose_twist: [theta, x, y]
    Output:
        SE2 [R p; 0 1]
    '''
    theta = pose_twist[0]
    x = pose_twist[1]
    y = pose_twist[2]
    R = theta_2_SO2(theta)
    p = np.array([x,y]).reshape(2,1)
    T = np.vstack([np.hstack([R, p]), np.array([[0, 0, 1]]) ])
    return T
    
def twist_to_SE2(twist):
    """
    Input: twist in unit time [theta, x, y], which is screw x theta. screw is [1, vx, vy].
    Output: T matrix SE2
        T = np.array([[R, P],
                      [0, 1]])
    """
    theta = twist[0]
    R = theta_2_SO2(theta)
    x = twist[1]
    y = twist[2]

    if theta == 0:
        G_theta_v = np.array([[x], [y]])
    else:
        vx = x/theta
        vy = y/theta
        R = theta_2_SO2(theta)
        w = 1 # this is the "omega axis "
        w_hat = hat(w)
        G_theta = np.identity(2)*theta + (1.0 - np.cos(theta))*w_hat + (theta - np.sin(theta))* w_hat.dot(w_hat)
        G_theta_v = G_theta.dot(np.array([[vx], [vy]]))

    T = np.vstack([np.hstack([R, G_theta_v]), np.array([[0, 0, 1]]) ])
    return T


def hat(w):
    """
    Returns the hatted version of a scalar w. The result is in so(3)
    """
    w_hat = np.array([[0.0, -w],
                      [w, 0.0]])
    return w_hat

def SO2_2_theta(R):
    """
    Input R is SO2 Rotation matrix.
    Sample Input: [[cos(theta) -sin(theta)],
        [sin(theta) cos(theta)]]
        Output is the angle of R
    Sample output: theta = pi/2
    """
    R = np.array(R)
    theta = np.arctan2(R[1,0], R[0,0])
    return theta

def SE2_to_Pose_Twist(T):
    '''
    In this program, we represent a robot's pose in a twist-like way: [theta,x,y]. However, this
    is NOT an actual twist, and the corresponding SE2 does not follow the standard "twist way".
    Args:
        T = np.array([[R, P],
           [0, 1]])
    Output: twist representation of the robot pose [theta, x, y]
    '''
    T = np.copy(T)
    R= T[: 2, : 2]
    p = T[:2, -1]
    theta = SO2_2_theta(R)
    pose_twist = np.append(theta, p)
    return pose_twist


def SE2_to_Twist(T):
    """
    Input: T matrix SE2
            T = np.array([[R, P],
                       [0, 1]])
    Output: twist in unit time [theta, x, y], which is screw x theta. screw is [1, vx, vy].
    """
    T = np.copy(T)
    R= T[: 2, : 2]
    p = T[:2, -1]
    theta = SO2_2_theta(R)
    if abs(theta)<1e-6:
        xy = p
    else:
        w = 1 #this is the omega axis
        w_hat = hat(w)
        G_minus1 = 1/theta * np.identity(2) - 1.0/2.0*w_hat + ( 1/theta - 1.0/2.0*(1.0/np.tan(theta/2.0)))*w_hat.dot(w_hat)
        v = G_minus1.dot(np.array([[p[0]], [p[1]]]))
        xy = np.array([v[0], v[1]])* theta

    twist = np.append(theta, xy)
    return twist


#--------------------------------------------------------------------node starts
        
class ekf_node(object):
    '''
    This is the class for ekf_node. It updates /map -> /odom TF
    Assume:
        1. joint_states is [left wheel, right wheel]
        2. the real_world node is always publishing odom messages.
        3. Observations come in at a much slower rate than odometry
    '''
    def __init__(self):
        self.odom_frame_id = rospy.get_param("~odom_frame_id")
        self.map_frame_id = rospy.get_param("~map_frame_id")
        self.map_odom_broadcaster = tf.TransformBroadcaster()
        self.joint_positions = np.array([0.0, 0.0])
        self.last_joint_positions = np.array([0.0, 0.0])

        self.last_update_time = 0.0
        self.landmarks = np.empty((0, 3))           #self.landmarks: [time, id, range, bearing, range_stddev, bearing_stddev]
        self.Twist_so = np.array([0.0, 0.0, 0.0])   #Twist: [theta, x, y]
        self.Twist_ob = np.array([0.0, 0.0, 0.0])
        self.T_control = np.identity(3)
        self.T_control_buffer = np.identity(3)  # During reset, T_control might be changed unintentionally by joint_states callback
        self.T_control_reset_flag = False
        self.T_control_bufferred_flag = False
        self.wheel_radius = rospy.get_param("~wheel_radius")
        self.wheel_base = rospy.get_param("~wheel_base")
        self.landmark_num = rospy.get_param("~circular_obstacles_num")

        self.ekf_obj = ekf_object(landmark_num = self.landmark_num)
        rospy.Subscriber("/joint_states", JointState, self.joint_states_callback)
        rospy.Subscriber("/landmarks", LandmarkList, self.landmarks_callback)
        rospy.Subscriber("/odom", Odometry, self.odom_callback)

    def publish_tf(self):
        self.map_odom_broadcaster.sendTransform((self.Twist_so[1], self.Twist_so[2], 0.0),
                                                tf.transformations.quaternion_from_euler(0.0, 0.0, self.Twist_so[0]),
                                                rospy.Time.now(),
                                                self.odom_frame_id,
                                                self.map_frame_id
                                                )

    def get_unnormalized_control_input(self):
        # Return: commanded control input np array [ theta_dot, x_dot,y_dot]
        # Assumption of this function is: landmark observations come before wheels finish half revolution.

        # get normalized wheel increments
        delta_wheel_pos = self.joint_positions - self.last_joint_positions
        l_vel = normalize_angle( delta_wheel_pos[0] )
        r_vel = normalize_angle( delta_wheel_pos[1] )
        PI = np.pi

        if abs(l_vel)> PI:
            l_vel = -1.0*l_vel/abs(l_vel) * (PI - abs(l_vel))
        if abs(r_vel)> PI:
            r_vel = -1.0*r_vel/abs(r_vel) * (PI - abs(r_vel))

        #get twist from wheel vel, then calculate [theta_dot, x_dot, y_dot]
        H = np.array([[-1.0 * self.wheel_radius/self.wheel_base, self.wheel_radius/self.wheel_base],
                      [self.wheel_radius/2.0, self.wheel_radius/2.0],
                      [0.0, 0.0]])
        u = np.array([l_vel, r_vel])
        v = H.dot(u)
        if v[0] == -PI:
            v[0] = PI

        # output= np.array([v[1], v[0]])
        return v


    def landmarks_callback(self, landmarks_msg):
        # In this step, we update the robot's estimated pose, by running the Filter
        self.landmarks = np.empty((0, 3))
        for i_landmark in range(len(landmarks_msg.landmarks)):
            landmark = landmarks_msg.landmarks[i_landmark]
            landmark_arr = np.zeros(3)
            landmark_arr = np.array([landmark.range,
                                     landmark.bearing,
                                     landmark.landmark_id
                                     ])
            self.landmarks = np.append(self.landmarks, landmark_arr.reshape(1,3), axis = 0)

        #TODO: test if only updating observations will work
        #TODO: test if innovation added externally
        # self.ekf_obj.measurement_update( self.landmarks)
        innovation = self.ekf_obj.measurement_update( self.landmarks)
        self.ekf_obj.miu += innovation
        #miu = ([2*n + 3]x1) matrix, [x, y, theta, mx1, my1...]
        new_miu= self.ekf_obj.miu[:,0]
        new_pose_twist = np.array([new_miu[2], new_miu[0], new_miu[1]])

        #calculate Tso by Tsb* inv(Tob)
        Tsb = pose_twist_to_SE2(new_pose_twist)
        Tbo = SE2_inv(pose_twist_to_SE2(self.Twist_ob))
        Tso = Tsb.dot(Tbo)
        self.Twist_so = SE2_to_Pose_Twist(Tso)

#
#         current_update_time = landmark.last_update
#         delta_t = current_update_time - self.last_update_time
#         self.last_update_time = current_update_time
#
# ##########################
#         self.T_control_reset_flag = True
#         T_control_temp = np.copy(self.T_control)
#         self.T_control = np.identity(3)
#         self.T_control_reset_flag = False
#
#         #         #TODO:
#         # print("--------")
#         # print("T_control should be all zero: ")
#         # print (self.T_control)
#
#         # if self.T_control_bufferred_flag == True:
#         #     self.T_control = self.T_control.dot(self.T_control_buffer)
#         #     self.T_control_buffer = np.identity(3)
#         #     self.T_control_bufferred_flag = False
#
#         commanded_control_twist = SE2_to_Twist(T_control_temp)  #[theta_dot, x_dot, y_dot]
#         commanded_control = np.array([ commanded_control_twist[1], commanded_control_twist[0] ]) / delta_t
#
# ##########################
#
#
#         self.ekf_obj.filter(commanded_control, self.landmarks, delta_t)
#
#         #miu = ([2*n + 3]x1) matrix, [x, y, theta, mx1, my1...]
#         new_miu= self.ekf_obj.miu[:,0]
#         new_pose_twist = np.array([new_miu[2], new_miu[0], new_miu[1]])
#
#         #calculate Tso by Tsb* inv(Tob)
#         Tsb = pose_twist_to_SE2(new_pose_twist)
#         Tbo = np.linalg.pinv(pose_twist_to_SE2(self.Twist_ob), rcond=1e-14)
#         Tso = Tsb.dot(Tbo)
#         self.Twist_so = SE2_to_Pose_Twist(Tso)


    def joint_states_callback(self, joint_states_msg):
        '''
        In order to reduce accumulative error from wheels, we update the body twist every time we receive a wheel pos update.
        Args: joint_states_msg: new wheel states
        '''
        self.joint_positions = np.array(joint_states_msg.position)
        instant_control_input_twist = self.get_unnormalized_control_input()   #[theta_dot, x_dot, y_dot]


        #if T_control is being reset, we want to buffer the control twist (only one control twist)
        self.T_control = self.T_control.dot( twist_to_SE2(instant_control_input_twist) )

        commanded_control_twist = SE2_to_Twist(self.T_control)  #[theta_dot, x_dot, y_dot]
        self.T_control = np.identity(3)
        delta_t = 1
        commanded_control = np.array([ commanded_control_twist[1], commanded_control_twist[0] ]) / delta_t
        self.ekf_obj.motion_predict(commanded_control, delta_t)
        new_miu= self.ekf_obj.miu[:,0]
        new_pose_twist = np.array([new_miu[2], new_miu[0], new_miu[1]])
        Tsb = pose_twist_to_SE2(new_pose_twist)

        Tbo = SE2_inv(pose_twist_to_SE2(self.Twist_ob))
        Tso = Tsb.dot(Tbo)
        self.Twist_so = SE2_to_Pose_Twist(Tso)
        self.publish_tf()
        #reset variables
        self.last_joint_positions = self.joint_positions


    def odom_callback(self, odom_msg):
        quat_x = odom_msg.pose.pose.orientation.x
        quat_y = odom_msg.pose.pose.orientation.y
        quat_z = odom_msg.pose.pose.orientation.z
        quat_w = odom_msg.pose.pose.orientation.w

        theta = tf.transformations.euler_from_quaternion((quat_x, quat_y, quat_z,quat_w))[2]
        self.Twist_ob[0] = theta
        self.Twist_ob[1] = odom_msg.pose.pose.position.x
        self.Twist_ob[2] = odom_msg.pose.pose.position.y




if __name__ == "__main__":
    try:
        rospy.init_node("ekf_node")
        ekf_node()
        rospy.spin()
    except rospy.ROSInterruptException:
        pass


#simple test cases:
# 1. /odom: translation to -1, angle to -pi/2, see if /map -> /odom will generate an inverse for these
# 2.

