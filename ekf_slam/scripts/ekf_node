#!/usr/bin/python
"""
This is the ekf node that filters the pose and the landmark locations, based on the control signal and the map.
How it works:
    a. Subscribe to /odom -> /baselink from odometer, gets the car's pose from odometry, then broadcast TF
    b. Subscribe to /landmarks to get landmark observations, then use EKF to estimate the robot and landmark pose
"""

import rospy
import numpy as np
import tf
from real_world.msg import LandmarkList
from sensor_msgs.msg import JointState
from nav_msgs.msg import Odometry
from ekf import ekf_object

#-------------------------------------------------------helper functions
# convert radians into [-pi, pi]
def normalize_angle(rad):
    _rad = rad - int((rad)/(2.0 * np.pi)) * (2.0*np.pi)
    if abs(_rad) > np.pi:
        _rad = -1.0*(2.0*np.pi-_rad) if _rad> 0 else 2.0*np.pi+_rad
    if _rad == -1*np.pi:
        _rad = np.pi
    return _rad


def transform(displacement, theta = 0):
    '''
    Make a SE2 matrix given theta and displacement
    Args:
        displacement: 1x2 array [x, y]
        theta: double
    Return:
         SE2 Matrix, ndarray 3x3
    '''
    s= np.sin(theta)
    c = np.cos(theta)
    x = displacement[0]
    y = displacement[1]
    T = np.array([[c, -s, x],
                  [s, c, y],
                  [0.0, 0.0, 1.0]])
    return T


def twist_to_SE2(twist):
    '''
    Convert a twist [theta, x, y] to SE2.
    Args:
        twist: [theta, x, y]
    Return:
        SE2 Matrix, ndarray 3x3
    '''
    theta = twist[0]
    if theta==0:
        T = transform([twist[1], twist[2]], twist[0])
        return T
    else:
        x = twist[1]
        y = twist[2]
        vx = x*1.0/theta
        vy = y*1.0/theta
        v = np.array([vx, vy])

        w_hat = np.array([[0.0, -1.0],
                          [1.0, 0.0]])
        I = np.identity(2)
        G_theta = I * theta + w_hat * (1.0-np.cos(theta)) + (w_hat.dot(w_hat)) * (theta - np.sin(theta))
        v_result = G_theta.dot(v)

        T = transform(v_result, theta)
        return T


def hat(w):
    """
    Returns the hatted version of a scalar w. The result is in so(3)
    """
    w_hat = np.array([[0.0, -w],
                      [w, 0.0]])
    return w_hat

def SO2_2_theta(R):
    """
    Input R is SO2 Rotation matrix.
    Sample Input: [[cos(theta) -sin(theta)],
        [sin(theta) cos(theta)]]
        Output is the angle of R
    Sample output: theta = pi/2
    """
    R = np.array(R)
    theta = np.arctan2(R[1,0], R[0,0])
    return theta

def SE2_to_Twist(T):
    """
    Input: T matrix SE2
            T = np.array([[R, P],
                       [0, 1]])
    Output: twist in unit time [theta, x, y], which is screw x theta. screw is [1, vx, vy].
    """
    T = np.copy(T)
    R= T[: 2, : 2]
    p = T[:2, -1]
    theta = SO2_2_theta(R)
    if abs(theta)<1e-6:
        xy = p
    else:
        w = 1 #this is the omega axis
        w_hat = hat(w)
        G_minus1 = 1/theta * np.identity(2) - 1.0/2.0*w_hat + ( 1/theta - 1.0/2.0*(1.0/np.tan(theta/2.0)))*w_hat.dot(w_hat)
        v = G_minus1.dot(np.array([[p[0]], [p[1]]]))
        xy = np.array([v[0], v[1]])* theta

    twist = np.append(theta, xy)
    return twist


#--------------------------------------------------------------------node starts
        
class ekf_node(object):
    '''
    This is the class for ekf_node. It updates /map -> /odom TF
    Assume:
        1. joint_states is [left wheel, right wheel]
        2. the real_world node is always publishing odom messages.
        3. Observations come in at a much slower rate than odometry
    '''
    def __init__(self):
        self.odom_frame_id = rospy.get_param("~odom_frame_id")
        self.map_frame_id = rospy.get_param("~map_frame_id")
        self.map_odom_broadcaster = tf.TransformBroadcaster()
        self.joint_positions = np.array([0.0, 0.0])
        self.last_joint_positions = np.array([0.0, 0.0])

        self.last_update_time = 0.0
        self.landmarks = np.empty((0, 3))           #self.landmarks: [time, id, range, bearing, range_stddev, bearing_stddev]
        self.Twist_so = np.array([0.0, 0.0, 0.0])   #Twist: [theta, x, y]
        self.Twist_ob = np.array([0.0, 0.0, 0.0])
        self.landmark_num = rospy.get_param("~circular_obstacles_num")

        self.wheel_radius = rospy.get_param("~wheel_radius")
        self.wheel_base = rospy.get_param("~wheel_base")

        self.ekf_obj = ekf_object(landmark_num = self.landmark_num)
        rospy.Subscriber("/joint_states", JointState, self.joint_states_callback)
        rospy.Subscriber("/landmarks", LandmarkList, self.landmarks_callback)
        rospy.Subscriber("/odom", Odometry, self.odom_callback)

    def publish_tf(self):
        self.map_odom_broadcaster.sendTransform((self.Twist_so[1], self.Twist_so[2], 0.0),
                                                tf.transformations.quaternion_from_euler(0.0, 0.0, self.Twist_so[0]),
                                                rospy.Time.now(),
                                                self.odom_frame_id,
                                                self.map_frame_id
                                                )

    def get_control_input(self):
        # Return: commanded control input np array [theta, x, y]
        # Assumption of this function is: landmark observations come before wheels finish half revolution.

        # get normalized wheel increments
        delta_wheel_pos = self.joint_positions - self.last_joint_positions
        l_vel = normalize_angle( delta_wheel_pos[0] )
        r_vel = normalize_angle( delta_wheel_pos[1] )
        PI = np.pi

        if abs(l_vel)> PI:
            l_vel = -1.0*l_vel/abs(l_vel) * (PI - abs(l_vel))
        if abs(r_vel)> PI:
            r_vel = -1.0*r_vel/abs(r_vel) * (PI - abs(r_vel))

        #get twist from wheel vel
        H = np.array([[-1.0 * self.wheel_radius/self.wheel_base, self.wheel_radius/self.wheel_base],
                      [self.wheel_radius/2.0, self.wheel_radius/2.0],
                      [0.0, 0.0]])
        u = np.array([l_vel, r_vel])
        v = H.dot(u)
        if v[0] == -PI:
            v[0] = PI

        return v


    def landmarks_callback(self, landmarks_msg):
        # # In this step, we update the robot's estimated pose, by running the Filter
        # self.landmarks = np.empty((0, 3))
        # for i_landmark in range(len(landmarks_msg.landmarks)):
        #     landmark = landmarks_msg.landmarks[i_landmark]
        #     landmark_arr = np.zeros(3)
        #     landmark_arr = np.array([landmark.range,
        #                              landmark.bearing,
        #                              landmark.landmark_id
        #                              ])
        #     self.landmarks = np.append(self.landmarks, landmark_arr.reshape(1,3), axis = 0)
        #
        # commanded_control = self.get_control_input()
        # current_update_time = landmark.last_update
        # delta_t = current_update_time - self.last_update_time
        #
        #
        # self.ekf_obj.filter(commanded_control, self.landmarks, delta_t)
        # #miu = ([2*n + 3]x1) matrix, [x, y, theta, mx1, my1...]
        # new_miu= self.ekf_obj.miu[:,0]
        # new_pose_twist = np.array([new_miu[2], new_miu[0], new_miu[1]])
        #
        # #calculate Tso by Tsb* inv(Tob)
        # Tsb = twist_to_SE2(new_pose_twist)
        # Tbo = np.linalg.pinv(twist_to_SE2(self.Twist_ob), rcond=1e-14)
        # Tso = Tsb.dot(Tbo)
        # self.Twist_so = SE2_to_Twist(Tso)
        #
        # self.last_joint_positions = self.joint_positions
        # self.last_update_time = current_update_time
        pass


    def joint_states_callback(self, joint_states_msg):
        self.joint_positions = np.array(joint_states_msg.position)
        self.publish_tf()

    def odom_callback(self, odom_msg):
        quat_x = odom_msg.pose.pose.orientation.x
        quat_y = odom_msg.pose.pose.orientation.y
        quat_z = odom_msg.pose.pose.orientation.z
        quat_w = odom_msg.pose.pose.orientation.w

        theta = tf.transformations.euler_from_quaternion((quat_x, quat_y, quat_z,quat_w))[2]
        self.Twist_ob[0] = theta
        self.Twist_ob[1] = odom_msg.pose.pose.position.x
        self.Twist_ob[2] = odom_msg.pose.pose.position.y




if __name__ == "__main__":
    try:
        rospy.init_node("ekf_node")
        ekf_node()
        rospy.spin()
    except rospy.ROSInterruptException:
        pass


#simple test cases:
# 1. /odom: translation to -1, angle to -pi/2, see if /map -> /odom will generate an inverse for these
# 2.

